#!/usr/bin/env python
# -*- coding: utf-8 -*-

import sys, os
import argparse
from ddtools._version import __version__
from ddtools.utilities import NormalizeParser


def main_parser():

	parser = argparse.ArgumentParser(prog='DDTools', usage='ddtools sub_command [-h] [--version]', description='''
	
DDTools is a bioinfomatic tool for DNA damage analysis. Especially for CLAPS-seq.
	
This is an open source project, all original codes are stored in github:

	https://github.com/Jyyin333/DDTools


Type [sub_command] to learn more detail infomation about sub-functions.

[Sub command]

	makeProject:

		Start a new project and help you write a pipeline script based on Snakemake.

	convertoBed:

		Convert Bam into Bed and filter the mapped reads at the same time.

	collectQC:

		Collect QC/Mapped results and generate an readable file. 

--------------------------------------------------------------------------------------------------
	THE FOLLOWING FUNCTIONS ARE USED FOR COMPUTING.

	seqContext:

		To analyze whether there is sequence context bias near damage sites.

	regAnnotation:

		To analyze the distribution differences of damage sites in different genomic regions.

	computeMTX:

		To calculate the signal of damage sites in a certain type of genomic region.

	computeGbias:

		To calculate the background content of one or more bases in a certain type of genomic region.

--------------------------------------------------------------------------------------------------
	THE FOLLOWING FUNCTIONS ARE USED FOR PLOTTING.

	plotContent:

		Various types of sequence context diagrams can be drawn using files generated by seqContext.

	plotAnnotation:

		This funciton creates boxplot of damage-signals in different genomic regions.

	plotMTX:

		By this function, a profile plot can be created using matrix which generated by computeMTX.

	plotGbias:

		To visulize the relationship  between DNA damage and background GC content.
		Or just want to look at the distribution of one or more particular bases in particular regions.

	''', epilog='''
Good luck !
	''',formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('--version', action='version',version='%(prog)s {}'.format(__version__))

	return parser



def test_parser():

	parser = argparse.ArgumentParser('Test sub-command', usage='ddtools test [options]', description='''
	This is a testing procedure.
	''',formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)
	parser.add_argument('-i','--number', nargs='+', default=[1,2,3,4,5], type=int, help='return max number')
	return parser


def makeProject():

	parser = argparse.ArgumentParser('makeProject', usage='ddtools makeProject [options]', description='''
	makeProject can help you initialize the configuration, and generate some initial files.
	This step is not necessary, but it's a good option if you're a Muggle or don't want to take the time to do it yourself.

	You can specify each parameter individually, for example:
		$ ddtools makeProject -n project_name -p platform -l libraryname

	or you can keep some/all list of arguments in a file and load parameters 
	by identifying that file at the command line, just as:
		$ ddtools makeProject @init_file

	Use only one of these two methods is recommended
	Of course you can mix them, but be aware that this can cause some parameter overrides,
	the last parameter to be read overwrites the previous same parameter.


	''',formatter_class=argparse.RawDescriptionHelpFormatter, fromfile_prefix_chars='@', add_help=True)

	parser.add_argument('-n', '--project_name', type=str, required=True, help='Give your project a name that prefixes all configuration files.')

	parser.add_argument('-l', '--library_name', type=str, required=True, help="Give your library a name, such as 'ChIP-seq', 'CLAPS-seq' ...")

	parser.add_argument('-g', '--fasta', required=True, help="Genome file in .fasta format.")

	parser.add_argument('-m','--aligner', required=True, default='bwa', choices=['bwa','bowtie','bowtie2'],
		help="Selecting a tool to mapping reads to genome. (default: %(default)s)")

	parser.add_argument('-i', '--aligner_index', required=True, help="Path to aligner index files. (with index prefix, e.g.: ~/home/usr/index/genome)")

	parser.add_argument('--aligner_params', type=str, help='Adding extra parameters for aligner you selected.')

	parser.add_argument('-q', '--mapq', type=int, metavar='INT', default=25, help='Reads with mapping quality less than this value will be discarded. (default: %(default)s)')

	#parser.add_argument('--cutadapt', action='store_true', help='If you want to pre-filterig fastq reads using cutadapt, then set this parameter.')

	parser.add_argument('--platform', type=str, default='Illumina', help='Information about the sequencing platform used. (default: %(default)s)')

	parser.add_argument('--cutadapt_params', type=str, help='Adding extra parameters for cutadapt.')

	parser.add_argument('--snake_threads', type=int, metavar='INT', default=1, help='Number of threads to use.')

	parser.add_argument('--picard', type=str, default=None, help='Path to file picard.jar')
	
	parser.add_argument('--run', action='store_true', help='If this parameter is specified, then the upstream analysis starts as soon as the snakefile is generated')
	
	return parser
	


def convertoBed():

	parser = argparse.ArgumentParser('convertoBed', usage='ddtools convertoBed [options]', description='''
	USing this sub-command to perform secondary filtering and convert format of data(Usually BAM to BED).
	The resulting BED can be used as an input file for downstream analysis. 

	This function is used automatically in the Snakefile generated by makeProject,
	but users could also use it directly with BAM.
	
	An example usage:
		$ ddtools convertoBed -b input.bam -g genome.fa -o result.bed

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-b', '--bam', required=True, help='Indexed bamfile.')

	parser.add_argument('-g', '--fasta', required=True, metavar='File', help='Genome file in .fasta format.')

	parser.add_argument('-o', '--out', required=True, help='File name to save results. (in bed format)')

	parser.add_argument('-q','--mapq', type=int, default=25, metavar='INT', help=
	'Reads with mapping quality less than this value will be discarded. (default: %(default)s)')

	parser.add_argument('-t', '--threads', type=int, metavar='INT', default=1, help='Number of threads to use. (default: %(default)s)')

	return parser


def seqContext():

	parser = argparse.ArgumentParser('seqContext', usage='ddtools seqContext [options]', description='''
	Since the DNA damage site is predicted to locate in 1-nt upstream of Read1 of the library constructed by End-Labeling,
	it is essential to interrogate the composition of Base types at this site.
	seqContext could counts the base composition at or near the predicted site.

	An example usage:
		$ ddtools seqContext -i input.bed -g genome.fa --prefix out
	
	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-i', '--input', required=True, help='Sample BED file with .tbi index.')

	parser.add_argument('-o', '--prefix', required=True, help='The prefix names of three output files.')

	parser.add_argument('-g', '--fasta', required=True, help='Genome fasta file.')

	parser.add_argument('-k', '--keep_bases', default=['A','G','C','T'], type=str, nargs='+', help=
		'Reads with specific base-type at damage site were keeped while others were discarded.'
		'Multiple types can be specified, but the length needs to be consistent.'
		'For example: "-k G C" or "-k TT TC", while "-k G GC" is not allowed.'
		'(default: %(default)s')

	parser.add_argument('-l','--left', type=int, default=5, metavar='INT', help=
		'The distance extending to the left from the center of the damage site. (default: %(default)s)')

	parser.add_argument('-r','--right', type=int, default=5, metavar='INT', help=
		'The distance extending to the right from the center of the damage site. (default: %(default)s)')

	parser.add_argument('-t', '--threads', type=int, metavar='INT', default=1, help='Number of threads to use. (default: %(default)s)')

	return parser


def computeMTX():
	
	NormalizingParser = NormalizeParser()
	parser = argparse.ArgumentParser('computeMTX', usage='ddtools computeMTX [options]', description='''
	computeMTX can be used to explore the distribution of signals within a given genomic region.
	There are two modes in this function:
		1. refpoint
		2. scale
	In the first mode, the signal values of the flanking area are calculated by centering on the reference point specified by user.
	In the second mode, there are two reference points(e.g. TSS and TES), and the area between them is first scale to the same length, and then the signal value is calculated.

	Alternatively, if "--bed" not specified and "--genome2bit" is specified, the program will count the base of specified type instead of signal.

	An example usage:
		$ ddtools computeMTX -m refpoint --reference_point TSS -i input.bed -k G -f genome.fa -r region.bed -o result.mtx.gz
		
		$ ddtools computeMTX -m scale -i input.bed -f genome.fa -k G -r region.bed -o result.mtx.gz

		$ ddtools computeMTX -m refpoint --reference_point TSS -g genome.2bit -k G -r region.bed -o result.mtx.gz
		
	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	# exclusive params 
	SCORE = parser.add_mutually_exclusive_group(required=True)

	SCORE.add_argument('-i', '--bed', help='Sample BED file with .tbi index.')

	SCORE.add_argument('-g', '--genome2bit', help='Genome file in 2bit format.')

	# shared params
	parser.add_argument('-r', '--region', required=True, help='Genome Region file in BED format.')

	parser.add_argument('-m', '--mode', required=True, choices=['refpoint','scale'], default='refpoint', help=
		'The computing mode.')

	parser.add_argument('-o', '--output', required=True, help='Output Filename with suffix of ".gz" to save results')

	parser.add_argument('-f', '--genomefasta', required=True, help='Genome file in FASTA format.')

	# optional params
	OPTIONAL = parser.add_argument_group('Universal', 'Parameters in this section are shared by different Running-Module.')

	OPTIONAL.add_argument('-k', '--keep_bases', default=['A','G','C','T'], type=str, nargs='+', help=
		'Reads with specific base-type at damage site were keeped while others were discarded.'
		'Multiple types can be specified, but the length needs to be consistent.'
		'For example: "-k G C" or "-k TT TC", while "-k G GC" is not allowed.'
		'(default: %(default)s')

	OPTIONAL.add_argument('-u', '--upstream', type=int, default=2000, help='Distance upstream of the reference point [bp].')

	OPTIONAL.add_argument('-d', '--downstream', type=int, default=2000, help='Distance downstream of the reference-point [bp].')

	OPTIONAL.add_argument('-bs', '--binsize', type=int, default=50, help=
		'Length in bases of the binsize calculating scores of the genome region of binsize. [bp].')

	OPTIONAL.add_argument('--method', default='RPKM', choices=['RPKM','CPM','DEPTH'], help='Method to normalizing signal. (default: %(default)s)')

	OPTIONAL.add_argument('--readLength', type=int, metavar='INT', help='The sequencing read length in bp.')

	OPTIONAL.add_argument('--genomeSize', help='Effective genome sizes should be given if you specify DEPTH as normalizing method.'
		'The input should be an integer, or specific reference genome name.'
		'Note: only hg19, hg18, mm9 and mm10 are built-in, please enter numbers for other types of genome.')

	OPTIONAL.add_argument('-j', '--cores', type=int, metavar='INT', default=1, help='Number of processor to use.')

	# unique params according to mode
	UNIQUE = parser.add_argument_group('Unique', 'Parameters in this section are specific to a particular Running-Module.')

	UNIQUE.add_argument('-c', '--reference_point', choices=['TSS','center','TES'], default='TSS', help=
		'In "refpoint" Mode, choose one of the %(choices)s as the reference point.')

	UNIQUE.add_argument('-s', '--stepsize', type=int, help=
		'Length in bases of the distance between bins in case of low sequencing depth, repeat sampling to amplify the signal.')

	UNIQUE.add_argument('-l', '--bodylength', type=int, help='Distance in bases to which all regions will be fit [bp].')

	return parser


def regAnnotation():
	parser = argparse.ArgumentParser('regAnnotation', usage='ddtools regAnnotation [options]',description='''
	Given a genomic region annotation file (with BED format), regAnnotation can count the number of reads and
	the background base content in each region.

	An example usage:
		$ ddtools regAnnotation -i input.bed -r region.bed -g genome.2bit -f genome.fa -o result.tsv

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-i', '--bed', required=True, help='Sample BED file with .tbi index.')

	parser.add_argument('-r', '--anno_file', required=True, help='Annotation file with BED format.')

	parser.add_argument('-k', '--keep_bases', default=['A','G','C','T'], type=str, nargs='+', help=
		'Reads with specific base-type at damage site were keeped while others were discarded.'
		'Multiple types can be specified, but the length needs to be consistent.'
		'For example: "-k G C" or "-k TT TC", while "-k G GC" is not allowed.'
		'(default: %(default)s')

	parser.add_argument('-g', '--genome2bit', help='Genome file in 2bit format.')

	parser.add_argument('-f', '--genomefasta', required=True, help='Genome file in FASTA format.')

	parser.add_argument('-o', '--output', help='Ouptput file to save results.')

	return parser


def computeGbias():
	parser = argparse.ArgumentParser('computeGbias', usage='ddtools computeGbias [options]',description='''
	In most cases, an ideal sample should show a uniform distribution of sequenced reads across the genome.
	More detail information refer to "https://deeptools.readthedocs.io/en/develop/content/tools/computeGCBias.html".
	But in some specific library constructing process(e.g. CLAPS-seq), there wil be sequence bias regardless of PCR-preference impacts.
	Therefore, this function could randomly selects multiple regions of the genome to explore whether there are some preferences in the signal distribution.

	An example usage:
		$ ddtools computeGbias -i input.bed -g genome.2bit -f genome.fa -o result.tsv

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-i', '--bed', nargs='+', required=True, help='Sample BED file with .tbi index.')

	parser.add_argument('-k', '--keep_bases', default=['A','G','C','T'], type=str, nargs='+', help=
		'Reads with specific base-type at damage site were keeped while others were discarded.'
		'Multiple types can be specified, but the length needs to be consistent.'
		'For example: "-k G C" or "-k TT TC", while "-k G GC" is not allowed.'
		'(default: %(default)s')

	parser.add_argument('-c', '--control', default=None, help=
		'Bed file of control group. Only one sample could be specified.')

	parser.add_argument('-n', '--samplesize', type=int, default=10000000, help='Number of sampling points to be considered.(default: %(default)s)')

	parser.add_argument('-l', '--regionsize', type=int, default=1000, help='The size of sampling points in bp.(default: %(default)s)')

	parser.add_argument('-g', '--genome2bit', help='Genome file in 2bit format.')

	parser.add_argument('-f', '--genomefasta', required=True, help='Genome file in FASTA format.')

	parser.add_argument('-o', '--output', help='Ouptput file to save results.')

	parser.add_argument('-j', '--cores', type=int, default=1, help='Number of processor to use.')

	return parser


def plotContext():

	parser = argparse.ArgumentParser('plotContext', usage='ddtools plotContext [options]', description='''
	plotContext is used to visualize results generated from seqContext.

	An example usage:
		$ ddtools plotContext -i input.tsv -o result.png

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)
	parser.add_argument('-i', '--input', required=True, help='.tsv files generated from seqContext.')

	parser.add_argument('-o', '--output', required=True, help='File name to save figure.')

	parser.add_argument('-c', '--control', required=False, default=None, help=
		'If treat.tri.tsv file was specified at params:input and control.tri.tsv file was given, then proportion of tri-bases of treat group would be '
		'divided by that of control group.')

	parser.add_argument('--mono_type', default='line', choices=['line', 'bar'], help=
		'If .mono.tsv file was given then it would be displayed as line plot by default. (Options: %(choices)s)')

	parser.add_argument('--di_type', default='line', choices=['line', 'bar'], help=
		'If .di.tsv file was given then it would be displayed as line plot by default. (Options: %(choices)s)')

	parser.add_argument('--di_keep', nargs='+', type=str, default=None, help=
		'Specifying the type of di-bases to be displayed at the output figure. If not given, all 16 types would be showned.')

	parser.add_argument('--tri_keep', nargs='+', type=str, default='A', choices=['A','C','G','T'], help=
		'In tri-bases, there are 36 types in all. Specifying one type of base to retain tri-bases with that base-type in the middle.')

	parser.add_argument('--title', type=str, default=None, help='Set title for figure. If not given, the name of input file would be used.')
	
	return parser


def plotMTX():

	parser = argparse.ArgumentParser('plotMTX', usage='ddtools plotMTX [options]', description='''
	plotMTX is used to visualize results generated from computeMTX.

	An example usage:
		$ ddtools plotMTX -i input.mtx.gz -o result.png

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-i', '--input', required=True, nargs='+', help='Score matrix file generated from computeMTX.')

	parser.add_argument('-o', '--output', required=True, help='File name to save figure.')

	parser.add_argument('-l', '--sampleLabels', type=str, nargs='+', default=None, help='Set label for each sample. If not given, the name of input file will be used.')

	parser.add_argument('-c', '--control', required=False, nargs='+', default=None, help=
		'Score matrix file of control group. '
		'Note: Multiple files of treat group(i.e. files in --input) would share the same control if only one control matrix file was provided.')

	parser.add_argument('--plotType', choices=['line','se','std'], default='line', help='Type of profile plot. (default: %(default)s)')

	parser.add_argument('--ref_label', type=str, default=None, help=
		'In mode of refpoint, the reference-point label is determined by input files automatically.'
		'Specifying this parameter to replace the default label.')

	parser.add_argument('--scale_label', type=str, nargs=2, default=['start','end'], help=
		'In mode of scale, the start and end point have no specific labels, it will be set to "satrt" and "end" respectively.'
		'Specifying this parameter to replace the default label.')

	parser.add_argument('--title', type=str, default=None, help='Set title for figure. If not given, the name of input file will be used.')

	parser.add_argument('--num_per_row', type=int, default=4, help='Number of plots per row.'
		'Note: It is exclusive with --merge. If --merge is specified, then this parameter will be ignored.')

	parser.add_argument('-m', '--merge', action='store_true', help=
		'If this parameter is specified, then images will be merged by template-strand or non-template-strand.')
	
	return parser



def plotAnnotation():

	parser = argparse.ArgumentParser('plotAnnotation', usage='ddtools plotAnnotation [options]', description='''
	plotAnnotation is used to visualize results generated from regAnnotation.

	An example usage:
		$ ddtools plotAnnotation -i input.tsv -o result.png

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)

	parser.add_argument('-i', '--input', required=True, help='Annotation results generated from regAnnotation.')

	parser.add_argument('-o', '--output', required=True, help='File name to save figure.')

	parser.add_argument('-c', '--control', required=False, default=None, help=
		'Annotation results of control group.'
		'If control file is specified, the figure will be showned in boxplot instead of barplot.')

	parser.add_argument('--colors', nargs='+', default=None, type=str, help='Specifing colors for different groups.'
		'It may overwrite the color values stored in input files.')

	parser.add_argument('--resort', nargs='+', default=None, type=str, help=
		'Different groups are sorted alphabetically by default.'
		'Set this parameter to re-order groups.')

	parser.add_argument('-bg', '--background_base', default=None, type=str, help=
		'Specifying one type of single-/di-bases, it will be presented in output figure in Second coordinate system.')

	parser.add_argument('--title', type=str, default=None, help='Set title for figure. If not given, the name of input file will be used.')

	return parser


def plotGbias():

	parser = argparse.ArgumentParser('plotGbias', usage='ddtools plotGbias [options]', description='''
	plotGbias is used to visualize results generated from computeGbias.

	An example usage:
		$ ddtools plotGbias -i input.tsv -o result.png

	''', formatter_class=argparse.RawDescriptionHelpFormatter, add_help=True)
	parser.add_argument('-i', '--input', required=True, help='.tsv files generated from computeGbias.')

	parser.add_argument('-o', '--output', required=True, help='File name to save figure.')

	parser.add_argument('-x', '--xtype', type=str, default='ALL', help='Choose the type of x-lable, G or GC.'
		'If not specified, the output figure will contains two subplots.')

	parser.add_argument('--file_index', type=int, nargs='+', default=None, help=
		'If multiple bedfiles were used in previous computeGbias, choose one of them or more to present in output figure.'
		'Using number index (1-based) to select specific samples.'
		'If not specified, all samples will be showned.')

	parser.add_argument('-l', '--sampleLabels', type=str, nargs='+', default=None, help='Set label for each sample. If not given, the name of input file will be used.')

	parser.add_argument('--plotType', choices=['line','se','std'], default='line', help='Type of profile plot. (default: %(default)s)')

	parser.add_argument('--title', type=str, default=None, help='Set title for figure.')
	
	return parser



def main(args=None):

	if len(sys.argv) == 1:
		cmd = ['--help']
		args = main_parser().parse_args(cmd)

	elif len(sys.argv) == 2 and sys.argv[-1] in ['-h', '--help', '-v', '--version']:
		cmd = [sys.argv[-1]]
		args = main_parser().parse_args(cmd)

	else:

		cmdList = sys.argv[2:]
		if len(cmdList) == 0:
			cmdList = ['--help']

		sub_command = sys.argv[1]

		if sub_command.startswith('-'):
			args = main_parser().parse_args(['--help'])

		elif sub_command == 'test':
			args = test_parser().parse_args(cmdList)
			from ddtools.test import main as _main
			_main(args)
		
		elif sub_command == 'makeProject':
			args = makeProject().parse_args(cmdList)
			from ddtools.makeProject import main as _main
			_main(args)

		elif sub_command == 'convertoBed':
			args = convertoBed().parse_args(cmdList)
			from ddtools.convertoBed import main as _main
			_main(args)

		elif sub_command == 'seqContext':
			args = seqContext().parse_args(cmdList)
			from ddtools.seqContext import main as _main
			_main(args)

		elif sub_command == 'computeMTX':
			args = computeMTX().parse_args(cmdList)
			from ddtools.computeMTX import main as _main
			_main(args)

		elif sub_command == 'regAnnotation':
			args = regAnnotation().parse_args(cmdList)
			from ddtools.regAnnotation import main as _main
			_main(args)

		elif sub_command == 'computeGbias':
			args = computeGbias().parse_args(cmdList)
			from ddtools.computeGbias import main as _main
			_main(args)

		elif sub_command == 'plotContext':
			args = plotContext().parse_args(cmdList)
			from ddtools.plotContext import main as _main
			_main(args)

		elif sub_command == 'plotMTX':
			args = plotMTX().parse_args(cmdList)
			from ddtools.plotMTX import main as _main
			_main(args)

		elif sub_command == 'plotAnnotation':
			args = plotAnnotation().parse_args(cmdList)
			from ddtools.plotAnnotation import main as _main
			_main(args)

		elif sub_command == 'plotGbias':
			args = plotGbias().parse_args(cmdList)
			from ddtools.plotGbias import main as _main
			_main(args)

		else:
			sys.exit('Error:\n\tsub_command "{}" is not existed.'.format(sub_command))



if __name__ == '__main__':
	main()

